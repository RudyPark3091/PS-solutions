## Problem
배낭이 수용할 수 있는 최대 무게와 각 물건의 무게, 가치가 주어질 때 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라   
##### 입력: 물건의 개수 N (1 <= N <= 100), 최대 무게 K (1 <= K <= 100000), 각 물건의 무게 W와 해당 물건의 가치 V (1 <= W <= 100000, 0 <= V <= 1000)   
##### 출력: 배낭에 넣을 수 있는 물건들의 최대 가치   
   
## Example
Input ->   
4 7   
6 13   
4 8   
3 6   
5 12   
   
Output ->   
14   
   
## Logic Flow   
이 문제는 널리 알려진 01 Knapsack 문제이다.   
이 문제를 해결하기 위해서는 `물건의 갯수 X 배낭의 최대 무게`만큼의 2차원배열이 필요하다.   
2차원배열 dp의 값 dp[i][j]는 i개의 물건이 있고 배낭의 최대 무게가 j일때의 배낭 안의 물건들의 가치의 총합을 의마한다.   
i번째 물건을 담는 경우와 담지 않는 경우로 나누어 생각한다.   
만약 i번째 물건을 담지 않는다면 배낭의 무게는 변화가 없으므로 이전 값을 그대로 가져와 `dp[i][j] = dp[i-1][j]`이다.   
i번째 물건을 담는 경우는 물건의 무게가 배낭의 무게보다 작은 경우만 가능하다.   
또한 i번째 물건을 담는다면 배낭의 최대 무게가 더 필요하므로 이전값에 i번째 물건의 가치만큼 더한 값을 저장한다.   
이를 점화식으로 표현하면 `dp[i][j] = dp[i-1][j-w[i]] + v[i]`와 같다. (w[i], v[i]는 각각 i번째 물건의 무게와 가치)   
이때 `j - w[i]`의 값이 0보다 작아진다면 인덱스에러가 발생한다.   
이는 현재 검사중인 j인덱스, 배낭의 최대 무게가 w[i]보다 작은 경우이므로 물건의 무게가 배낭의 무게보다 작아야한다는 전제조건에서 걸러진다.   
또한 문제에서 배낭이 수용가능한 최대 무게가 주어졌기 때문에 우리는 j 인덱스를 K까지만 순회한다.   
따라서 `j - w[i]`에 의해 프로그램이 Abort될 상황은 일어나지 않는다.   
결론적으로 i번째 물건에 대해서는 담는 경우와 담지 않는 경우 둘 중 더 큰 값을 저장해야하므로 `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`의 점화식을 따른다.   
이 방법으로 i, j의 순회를 모두 마치면 dp[N]의 최댓값을 출력한다.   
   
## Source Code
``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, k;
int dp[101][100001];
int w[101];
int v[101];

void input() {
  cin >> n >> k;

  for (int i = 1; i <= n; i++) { cin >> w[i] >> v[i]; }
}

void solve() {
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      if (j - w[i] >= 0) { dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]); }
      else { dp[i][j] = dp[i-1][j]; }
    }
  }

  cout << dp[n][k] << '\n';
}

int main() {
  input();
  solve();
  return 0;
}
```   

