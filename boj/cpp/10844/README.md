## Problem
N을 입력받아 길이가 N인 "계단 수"의 개수를 출력한다.   
단 0으로 시작하는 수는 없다.   
##### 입력: 정수 N (1 <= N <= 100)   
##### 출력: "계단 수"의 개수를 1,000,000,000 (10억)으로 나눈 나머지   

## Example
1 ->   
1, 2, 3, 4, 5, 6, 7, 8, 9 : 출력 - 9
   
2 ->   
10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98 : 출력 - 17   
   
3 ->   
101, 121, 123, 210, 212, 232, 234, 321, 323, 343, 345, 432, 434, 454, 456, 
543, 545, 565, 567, 654, 656, 676, 678, 765, 767, 787, 789, 876, 878, 898, 
987, 989 : 출력 - 32   
N이 1씩 증가할수록 수의 앞자리 또는 뒷자리에 올수 있는 수가 생긴다.   
여기서 실마리를 찾아 dp 알고리즘을 구현한다.   

## Logic Flow
N이 1일때 계단 수는 9개이다.   
N이 2일때 각각의 수에 대해 앞자리, 뒷자리에 증가한 수, 감소한 수가 붙는 분기가 생긴다   
N이 1 증가할때마다 겹치는 경우가 생기므로 뒷자리에 증가한수, 감소한 수가 붙는 경우만 고려한다.   
이전 수의 가장 뒷자리 수가 0이라면 그 뒤에는 1만 붙일 수 있다.   
이전 수의 가장 뒷자리 수가 9라면 그 뒤에는 8만 붙일 수 있다.   
N의 최대 길이가 100이므로 길이 101의 배열이 필요하다.   
이때 끝자리 수에 따라 다른 연산을 해야하므로 분기를 위해 이차원 배열을 선언한다.   
배열의 각 원소는 길이가 N이고, M으로 끝나는 계단 수의 갯수이다.   
N=2 일때부터 시작해야하므로 배열의 첫 원소는 {1}로 초기화한다.   
arr[N][M]은 가장 마지막 자리의 수가 1에서 8인 경우 arr[N-1][M-1] + arr[N-1][M+1] 로 표현되고,   
가장 마지막 자리의 수가 0인 경우는 arr[N][0] = arr[N-1][1]로 표현되고,   
가장 마지막 자리의 수가 9인 경우는 arr[N][9] = arr[N-1][8]로 표현된다.   
위 방식으로 2부터 N 안에 0부터 10의 nested iteration을 돌린다. (Bottom-Up 방식)   
iteration이 끝나면 N번째 배열요소의 총합을 출력한다.   

## Source Code
``` cpp
#include <iostream>
#define DIVIDOR 1000000000
using namespace std;

int n;
long long arr[101][10] = {{0},{0,1,1,1,1,1,1,1,1,1},};

int main() {
    long long sum = 0;
    cin >> n;

    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < 10; j++) {
            if (j == 0) { arr[i][j] = arr[i-1][j+1]; }
            else if (j == 9) { arr[i][j] = arr[i-1][j-1]; }
            else { arr[i][j] = (arr[i-1][j-1] + arr[i-1][j+1]) % DIVIDOR; }
        }
    }

    for (int i = 0; i < 10; i++) { sum += arr[n][i]; }

    cout << sum % DIVIDOR << '\n';
    return 0;
}
```

## Review
sum의 타입을 int 로 잘못넣어 계속 틀렸습니다를 받았다.   
파이썬을 쓸게 아니면 타입에 신경쓸것.   
