## Problem
포도주를 마시는 조건
* 잔을 선택하면 그 잔에 담긴것을 모두 마셔야 하고 다 마신 뒤에는 원래 위치에 다시 놓아야한다.   
* 연속으로 놓여있는 3잔을 마실 수는 없다.   
   
1부터 n까지의 번호가 붙어있는 n개의 포도주 잔이 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 가능한 많은 포도주를 마실 수 있는 방법은?   

##### 입력: 정수 n (1 <= n <= 10,000), 포도주 잔에 들어있는 포도주의 양들
##### 출력: 마실 수 있는 포도주의 양의 최댓값   
   
## Example
n = 6, 포도주의 양 = 6, 10, 13, 9, 8, 1   
 -> 6, 10, 9, 8 = 33   
   
n = 4, 포도주의 양 = 1, 1, 1, 1   
 -> 1, 1, 1 = 3
   
n = 5, 포도주의 양 = 2, 1, 10, 1, 2   
 -> 2, 10, 2 = 14   
   
n = 5, 포도주의 양 = 2, 1, 10, 3, 2   
 -> 2, 10, 3 = 15
   
## Logic Flow
n은 1만보다 작거나 같은 자연수이므로 길이 10,001의 포도주의 양을 입력받을 배열 arr과, 최댓값을 저장할 배열 dp를 선언한다. (인덱스 1부터 값을 넣는다.)   
이때 포도주의 양은 1000보다 이하의 정수이므로 출력값은 1천만 이하로 int형으로 선언해도 안전하다.   
i번째 포도주를 마실지 안 마실지 결정하기 위해 i-3번째 포도주를 검사한다.   
만약 i-3번째 포도주가 두잔 연속으로 마신 포도주라면 i-2번째 포도주는 마실 수 없으므로 dp[i] = dp[i-3] + arr[i-1] + arr[i] 이 된다.   
i-3번째 포도주가 한잔째 마신 포도주라면, i-2번째 포도주와 i번째 포도주를 마셔 dp[i] = dp[i-2] + dp[i] 가 된다.   
또한 두 잔 연속으로 마시지 않아야 최댓값이 되는 경우가 존재한다.   
이런 경우엔 dp[i]의 값을 다음 인덱스로 넘겨줘야 하기 때문에 dp[i]에 dp[i]와 dp[i-1] 중 더 큰 값을 dp[i]로 채택한다.   
i=1일때엔 arr[1]의 값, i=2일때엔 arr[1]+arr[2], i=3일때엔 arr[1]+arr[3]과 arr[2]+arr[3] 중 더 큰 값을 초기화한다.   
i를 4부터 n까지 iteration 돌리면 dp의 모든 값이 초기화된다.   
dp[n] 을 출력한다.   
   
## Source Code
``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, res;
int arr[10001];
int dp[10001];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) { cin >> arr[i]; }
    dp[1] = arr[1];
    dp[2] = arr[1] + arr[2];

    for (int i = 3; i <= n; i++) {
        dp[i] = max(dp[i-3] + arr[i-1] + arr[i], dp[i-2] + arr[i]);
        dp[i] = max(dp[i-1], dp[i]);
    }

    cout << dp[n] << '\n';
    return 0;
}
```

## Review
정말 어이없게도 다 맞춰놓고 arr과 dp를 잘못써서 틀렸습니다를 받았다.   
좀더 꼼꼼해지자.