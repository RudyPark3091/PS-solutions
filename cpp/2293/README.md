## Problem
[acmicpc.net/problem/2293]
  
## Example
input ->  
3 10  
1  
2  
5  
  
output ->  
10  
  
1 * 10   
-> 1개  
  
2원 & 1원  
2 * 1 + 1 * 8  
2 * 2 + 1 * 6  
2 * 3 + 1 * 4  
2 * 4 + 1 * 2  
2 * 5  
-> 5개  
  
5원 & 1원  
5 * 1 + 1 * 5  
5 * 2  
-> 2개  
  
5원 & 2원 & 1원  
5 * 1 + 2 * 1 + 1 * 3  
5 * 1 + 2 * 2 + 1 * 1  
-> 2개  
  
==> 총 10개  
  
## Logic
이 문제는 메모리 제한이 4MB라 사용하지 않는 값을 버리는 기법이 필요하다.  
일반적인 풀이로는, `동전의 개수 x 만들려는 가치`의 2차원 배열을 선언해 사용하는 동전의 개수를 하나씩 늘려가며 계산을 한다.  
하지만, 메모리가 제한되어있기 때문에 2차원 배열을 선언하여 순회하기보단 2차원 배열의 가로길이만큼의 1차원 배열을 선언해 해당 배열에서 순회를 동전의 갯수만큼 반복하는 방법으로 계산해야 한다.  
2차원배열을 사용할때 i번째 동전을 사용해서 k원을 만든다고 생각하면,  
i개의 동전을 사용해 k원을 만드는 경우의 수인 dp[i][j]값은 dp[i][j - (i번째 동전의 가치)]에 dp[i-1][j]를 더한 값이 된다.  
다시말해, 이 문제의 점화식은 `dp[i][j] = dp[i][j - arr[i]] + dp[j]`가 된다.  
이를 단순히 1차원 배열을 사용하도록 바꿔주면 `dp[j] = dp[j - arr[i]] + dp[j]` 가 된다.  
이때 k < arr[i] 인 경우는 동전의 가치가 k보다 큰 경우이므로 그냥 추가로 더해줄 경우의 수가 없으므로 신경쓰지 않아도 된다.  
  
  
## Source Code
``` cpp
```
  
[acmicpc.net/problem/2293]: https://acmicpc.net/problem/2293
